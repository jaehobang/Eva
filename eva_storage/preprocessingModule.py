"""
This module performs the preprocessing step.
Performs basic computer vision techniques and background subtraction for preparing the inputs of the network
If any issues arise please contact jaeho.bang@gmail.com

@Jaeho Bang

"""

import numpy as np
import cv2
from loaders.loader_uadetrac import LoaderUADetrac

TIMED = True


class PreprocessingModule:

    def __init__(self):
        self.images = None
        self.video_start_indexes = None

    def run(self, images:np.ndarray, video_start_indices:list):
        # fgbg only takes grayscale images, we need to convert
        images_gray = np.mean(images, axis = 3)

        segmented_images = np.ndarray(shape = images_gray.shape)
        for i in range(len(video_start_indices)):
            # start index is inclusive, end index is not inclusive
            start_index = video_start_indices[i]
            if i == len(video_start_indices) - 1:
                end_index = images_gray.shape[0]
            else:
                end_index = video_start_indices[i + 1]
            fgbg = cv2.createBackgroundSubtractorKNN(detectShadows = True)

            # first round is to tune the values of the background subtractor
            for ii in range(start_index, end_index):
                fgbg.apply(images_gray[ii])

            # second round is to extract the masked values
            for ii in range(start_index, end_index):
                segmented_images[ii] = fgbg.apply(images_gray[ii])

        segmented_images = self._postfgbg(segmented_images)

        return segmented_images

    def _postfgbg(self, segmented_images):
        """
        Performs cv functions on outputs of background subtraction algorithms
        :param segmented_images: images generated by background subtraction algorithms
        :return: cv applied segmentation images
        """
        new_segmented_images = np.ndarray(shape = segmented_images.shape)
        kernel = np.ones((3,3), np.uint8)

        for i in range(segmented_images.shape[0]):
            blur = cv2.GaussianBlur(segmented_images, (3,3), 0)
            opening = cv2.morphologyEx(blur, cv2.MORPH_OPEN, kernel, iterations = 1)
            ret, thresh = cv2.threshold(opening, 0, 255, cv2.THRESH_OTSU)
            new_segmented_images[i] = thresh

        new_segmented_images = new_segmented_images.astype(np.uint8)
        return new_segmented_images









if __name__ == "__main__":
    loader = LoaderUADetrac()
    images = loader.load_images()
    labels = loader.load_labels()
    boxes = loader.load_boxes()
    video_start_indices = loader.get_video_start_indices()
    #images loaded as 300x300 - prepare the images
    preprocessor = PreprocessingModule()
    segmented_images = preprocessor.run(images, video_start_indices)



